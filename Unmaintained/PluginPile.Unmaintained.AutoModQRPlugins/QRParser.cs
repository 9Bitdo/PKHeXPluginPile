using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;
using PKHeX.Core;
using System.Diagnostics;
using System.Text;
using ZXing.Common;
using ZXing.Windows.Compatibility;

namespace PluginPile.Unmaintained.AutoModQRPlugins; 
public static class QRParser {
  /// <summary>
  /// Gets QR image from HTTP requests.
  /// </summary>
  public static async Task<Image?> GetQRData(string SaveID, string TeamID, string Cookie) {
    byte[] data = Encoding.ASCII.GetBytes($"savedataId={SaveID}&battleTeamCd={TeamID}");

    using HttpClient httpClient = new HttpClient();
    httpClient.DefaultRequestHeaders.Accept.ParseAdd("*/*");
    httpClient.DefaultRequestHeaders.Add("Accept-Encoding", "gzip, deflate, br");
    httpClient.DefaultRequestHeaders.Add("Accept-Language", "en-US,en;q=0.8");
    httpClient.DefaultRequestHeaders.Add("Cookie", Cookie);
    httpClient.DefaultRequestHeaders.Host = "3ds.pokemon-gl.com";
    httpClient.DefaultRequestHeaders.Add("Origin", "https://3ds.pokemon-gl.com/");
    httpClient.DefaultRequestHeaders.Referrer = new Uri($"https://3ds.pokemon-gl.com/rentalteam/{TeamID}");
    httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36");

    const string pglURL = "https://3ds.pokemon-gl.com/frontendApi/battleTeam/getQr";
    HttpResponseMessage response = await httpClient.PostAsync(pglURL, new ByteArrayContent(data));
    response.EnsureSuccessStatusCode();
    await using Stream stream = await response.Content.ReadAsStreamAsync();

    //add failing validation.
    try {
      return Image.FromStream(stream);
    } catch (Exception ex) {
      Debug.WriteLine(ex.Message);
      //invalid QR
      return null;
    }
  }

  private static byte[] ParseQR(Image q) {
    using Bitmap bitmap = new Bitmap(q);
    BarcodeReader reader = new BarcodeReader { AutoRotate = true, Options = new DecodingOptions { TryInverted = true } };
    byte[] data = reader.Decode(bitmap).RawBytes;
    return Array.ConvertAll(data, a => a);
  }

  private static byte[] ShiftArray(byte[] b) {
    byte[] array = new byte[507];
    byte rb = 0;
    for (int i = 0; i < array.Length; i++) {
      byte B = b[i];
      byte lb = (byte)((B & 0xF0) >> 4);
      array[i] = (byte)(rb << 4 | lb);
      rb = (byte)(B & 0xF);
    }

    return array;
  }

  private static byte[] ToByteArray(string toTransform) {
    return Enumerable
        .Range(0, toTransform.Length / 2)
        .Select(i => Convert.ToByte(toTransform.Substring(i * 2, 2), 16))
        .ToArray();
  }

  private static byte[] QR_t(ReadOnlySpan<byte> qr) {
    byte[] aes_ctr_key = ToByteArray("0F8E2F405EAE51504EDBA7B4E297005B");

    //byte[] metadata_flags = qr[..0x08].ToArray();
    byte[] ctr_aes = qr.Slice(0x08, 0x10).ToArray();
    byte[] data = qr.Slice(0x18, 0x1CE).ToArray();
    //byte[] sha1 = qr.Slice(0x1E6, 8).ToArray();

    IBufferedCipher cipher = CipherUtilities.GetCipher("AES/CTR/NoPadding");
    cipher.Init(false, new ParametersWithIV(new KeyParameter(aes_ctr_key), ctr_aes));

    return cipher.ProcessBytes(data);
  }

  public static RentalTeam? DecryptQRCode(Image QR) {
    //Read the bytes of the QR code
    byte[] data = ParseQR(QR);

    //All data is shifted to the left by 4. Shift the data to the correct location.
    data = ShiftArray(data);

    //ZXing has added the header bytes to the raw bytes. These are the first 3, so skip them.
    byte[] qrue = data.Skip(3).ToArray();

    //MEME CRYPTO!!! De-Meme the data
    if (!MemeCrypto.VerifyMemePOKE(qrue, out byte[] qrt)) {
      Console.WriteLine("it failed");
      return null;
    }

    //unencrypt the data in the plaintext.
    byte[] qrDec = QR_t(qrt);

    //build the rental team.
    return new RentalTeam(qrDec);
  }
}
